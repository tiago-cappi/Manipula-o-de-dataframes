# -*- coding: utf-8 -*-
"""Análise-produtos-clientes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uBlLOSjfhnxftq8rnuicsNFitmLqAEfq
"""



import pandas as pd
import ipywidgets as widgets
from IPython.display import display






import pandas as pd



def ler_excel_para_dataframe(caminho_arquivo):
    """
    Lê um arquivo Excel e o carrega como um DataFrame do Pandas.

    Args:
        caminho_arquivo (str): O caminho completo para o arquivo Excel.

    Returns:
        pandas.DataFrame: O DataFrame contendo os dados do arquivo Excel.
        None: Se ocorrer um erro ao ler o arquivo.
    """
    try:
        df = pd.read_excel(caminho_arquivo)
        return df
    except Exception as e:
        print(f"Erro ao ler o arquivo Excel: {e}")
        return None



df_analise_comercial = ler_excel_para_dataframe("Análise comercial 01-01-22 28-02-25.xlsx")
df_categorias_produtos = ler_excel_para_dataframe("Classificação Produtos (3).xlsx")

df_analise_comercial

def classificar_clientes_abc(df):
    """
    Classifica os clientes conforme análise ABC baseada no valor orçado.

    Parâmetros:
    - df: DataFrame com dados de clientes e valores orçados

    Retorna:
    - DataFrame com a classificação ABC dos clientes, onde:
      - Categoria A: Clientes que representam até 80% do valor total orçado
      - Categoria B: Clientes que representam de 80.01% até 95% do valor total
      - Categoria C: Clientes que representam de 95.01% até 100% do valor total
    """
    # Verificar se o dataframe possui as colunas necessárias
    colunas_necessarias = ["Cliente", "Nome Cliente", "Valor Orçado", "UF", "Cidade"]
    if not all(col in df.columns for col in colunas_necessarias):
        print("Erro: O dataframe não possui todas as colunas necessárias para classificação ABC.")
        return pd.DataFrame(columns=["Cliente", "Nome Cliente", "Valor Total Orçado", "ABC", "UF", "Cidade"])

    # Verificar se o dataframe está vazio
    if df.empty:
        print("Aviso: O dataframe está vazio.")
        return pd.DataFrame(columns=["Cliente", "Nome Cliente", "Valor Total Orçado", "ABC", "UF", "Cidade"])

    try:
        # Agrupar por cliente e somar o valor orçado
        df_clientes = df.groupby(["Nome Cliente", "Cliente"])["Valor Orçado"].sum().reset_index()

        # Ordenar por valor orçado em ordem decrescente
        df_clientes = df_clientes.sort_values("Valor Orçado", ascending=False)


        # Calcular o valor total orçado para todos os clientes
        valor_total = df_clientes["Valor Orçado"].sum()

        # Calcular o percentual de cada cliente em relação ao total
        df_clientes["Percentual"] = df_clientes["Valor Orçado"] / valor_total * 100

        # Calcular o percentual acumulado
        df_clientes["Percentual Acumulado"] = df_clientes["Percentual"].cumsum()

        # Definir a classificação ABC baseada no percentual acumulado
        df_clientes["ABC"] = df_clientes["Percentual Acumulado"].apply(
            lambda x: "A" if x <= 80 else ("B" if x <= 95 else "C")
        )

        # Renomear coluna para maior clareza
        df_clientes = df_clientes.rename(columns={"Valor Orçado": "Valor Total Orçado"})

        # Converter a coluna "Valor Total Orçado" para numérico
        df_clientes['Valor Total Orçado'] = pd.to_numeric(df_clientes['Valor Total Orçado'], errors='coerce')

        #Rankeia os clientes com maiores valores orçados para os com menores valores orçados
        df_clientes['Ranking'] = df_clientes['Valor Total Orçado'].rank(ascending=False, method='min').astype(int)

        # Ordenar o DataFrame pela coluna "Valor Total Orçado" em ordem decrescente
        df_clientes = df_clientes.sort_values("Valor Total Orçado", ascending=False)

        # Adicionar as colunas UF e Cidade ao df_clientes
        df_clientes = pd.merge(df_clientes, df[['Cliente', 'UF', 'Cidade']].drop_duplicates(subset=['Cliente']), on='Cliente', how='left')


        return df_clientes[["Cliente", "Nome Cliente", "UF", "Cidade", "Valor Total Orçado", "ABC", "Percentual", "Percentual Acumulado", "Ranking"]]

    except Exception as e:
        print(f"Erro ao processar classificação ABC: {e}")
        return pd.DataFrame(columns=["Cliente", "Nome Cliente", "Valor Total Orçado", "ABC"])


df_classificacao_abc = classificar_clientes_abc(df_analise_comercial)

#Formatar a coluna "Valor Total Orçado" para o formato de moeda brasileira (R$)
df_classificacao_abc['Valor Total Orçado'] = df_classificacao_abc['Valor Total Orçado'].apply(lambda x: "R$ {:,.2f}".format(x) if not pd.isnull(x) else "")


#Formatar as colunas "Percentual" e "Percentual Acumulado" para porcentagem com duas casas decimais
df_classificacao_abc['Percentual'] = df_classificacao_abc['Percentual'].apply(lambda x: "{:.2f}%".format(x) if not pd.isnull(x) else "")
df_classificacao_abc['Percentual Acumulado'] = df_classificacao_abc['Percentual Acumulado'].apply(lambda x: "{:.2f}%".format(x) if not pd.isnull(x) else "")

df_classificacao_abc

def juntar_categorias_produtos(df, caminho_excel=None):
    """
    Carrega um arquivo Excel com categorias de produtos e realiza um merge
    com o dataframe principal baseado na coluna "Código Produto", incluindo apenas
    as colunas "Negócio", "Grupo" e "Subgrupo".

    Parâmetros:
    - df: DataFrame do pandas com os dados de vendas
    - caminho_excel: Caminho para o arquivo Excel com as categorias (opcional)

    Retorna:
    - DataFrame resultante da junção
    """
    if caminho_excel is None:
        # Se não for fornecido um caminho específico, assume um caminho padrão na pasta do projeto
        caminho_excel = r"Classificação Produtos (3).xlsx"

    try:
        # Carregar o arquivo Excel com as categorias
        df_categorias = pd.read_excel(caminho_excel, "Base")

        # Verificar se a coluna chave existe em ambos os dataframes
        if "Código Produto" not in df.columns or "Código Produto" not in df_categorias.columns:
            print("Aviso: Coluna 'Código Produto' não encontrada em um ou ambos os dataframes.")
            return df

        # Selecionar apenas as colunas desejadas do df_categorias
        df_categorias = df_categorias[["Código Produto", "Negócio", "Grupo", "Subgrupo"]]

        # Realizar o merge dos dataframes pela coluna "Código Produto"
        # Usa left join para preservar todos os registros do dataframe original
        df_resultado = pd.merge(
            df,
            df_categorias,
            on="Código Produto",
            how="left"
        )

        return df_resultado

    except Exception as e:
        print(f"Erro ao carregar ou mesclar o arquivo Excel: {e}")
        # Retorna o dataframe original em caso de erro
        return df

# prompt: Junte o dataframe df_classificacao_abc com o df_analise_comercial jutando os códigos "Cliente" de ambos dataframes e agrupe por Cliente. O resultado final quero apenas "Código Produto", "Descrição Produto" e "Dt Entrada" de df_analise_comercial e "Nome Cliente", "UF", "Cidade", "ABC" de df_classificacao_abc. Faça um inner join. Utilize apenas as colunas "Código Produto", "Descrição Produto" e "Dt Entrada" de df_analise_comercial para fazer essa junção.

import pandas as pd
# Realizar o merge dos dataframes com base na coluna "Cliente"
df_resultado = pd.merge(df_analise_comercial [["Código Produto", "Descrição Produto", "Dt Entrada", "Cliente", "Consultor Interno", "Prob.Fech.", "Motivo Não Venda"]], df_classificacao_abc, on='Cliente', how='inner')

df_resultado

# prompt: Agrupe df_resultado por "Código Produto" e por "Cliente" e mostre o resultado

# Agrupar df_resultado por "Código Produto" e "Cliente" e mostrar o resultado
df_pedidos = df_resultado.groupby(["Dt Entrada", "Código Produto", "Cliente"]).agg({
    "Nome Cliente": "first",
    "Descrição Produto": "first",
    "UF": "first",
    "Cidade": "first",
    "ABC": "first",
    "Ranking": "first",
    "Prob.Fech.": "first",
    "Motivo Não Venda": "first",
    "Valor Total Orçado": "first",
    "Consultor Interno": "first"
}).reset_index()

df_pedidos



# Juntar df_pedidos com df_categorias_produtos usando a coluna "Código Produto"
df_resultado_final = juntar_categorias_produtos(df_pedidos, caminho_excel=r"Classificação Produtos (3).xlsx")

df_resultado_final

# Converter a coluna 'Dt Entrada' para o formato desejado
df_resultado_final['Dt Entrada'] = pd.to_datetime(df_resultado_final['Dt Entrada']).dt.strftime('%d/%m/%Y')

# Função para criar a tupla, omitindo 'Motivo Não Venda' se for vazio
def criar_tupla(linha):
    motivo = linha['Motivo Não Venda']
    if pd.isna(motivo) or motivo == "":  # Verifica se o motivo é vazio ou NaN
        return (linha['Dt Entrada'], linha['Prob.Fech.'], linha['Consultor Interno'])
    else:
        return (linha['Dt Entrada'], linha['Prob.Fech.'], linha['Consultor Interno'], motivo)

# Criar a nova coluna 'Tupla_Dados' com as tuplas
df_resultado_final['Tupla_Dados'] = df_resultado_final.apply(criar_tupla, axis=1)

# Exibir o DataFrame resultante
df_resultado_final

df_categorias = df_resultado_final.groupby(["Negócio", "Grupo", "Subgrupo"]).agg({"Código Produto": "first"}).reset_index()
df_categorias = df_categorias.drop(["Código Produto"], axis=1)
df_categorias

import pandas as pd

# Função para pegar o primeiro elemento da lista, verificando se é uma lista ou iterável
def primeiro_elemento(valor):
    if isinstance(valor, (list, pd.core.series.Series)):  # Verifica se é uma lista ou uma Series do pandas
        if len(valor) > 0:  # Verifica se a lista/Series não está vazia
            if all(x == valor.iloc[0] if isinstance(valor, pd.core.series.Series) else x == valor[0] for x in valor):  # Verifica se todos os elementos são iguais
                return valor.iloc[0] if isinstance(valor, pd.core.series.Series) else valor[0]  # Retorna o primeiro elemento
            else:
                return valor
        else:
            return None  # Retorna None se a lista/Series estiver vazia
    else:
        return valor  # Se não for uma lista ou Series, retorna o valor original

# Função para formatar a tupla com quebras de linha
def formatar_tupla(tupla):
    """Formata a tupla como uma string com quebras de linha, incluindo uma linha vazia entre cada elemento."""
    return '\n\n\n'.join(map(str, tupla))  # Adiciona uma quebra de linha extra

# Função para extrair a última data (mais recente) de uma lista de datas
def ultima_data(datas):
    if isinstance(datas, list) and len(datas) > 0:
        return max(datas).strftime("%d/%m/%Y")  # Formatar como dd/mm/yyyy
    else:
        return None

# Filtrar clientes de categoria "A" em "ABC" e "SSO" em "Negócio"
df_filtrado = df_resultado_final

# Converter a coluna 'Dt Entrada' para datetime
df_filtrado['Dt Entrada_temp'] = pd.to_datetime(df_filtrado['Dt Entrada'], format='%d/%m/%Y')

# Filtrar datas entre 03/01/2022 e 28/02/2025
df_filtrado = df_filtrado[
    (df_filtrado["Dt Entrada_temp"] >= pd.to_datetime("2022-01-01")) &
    (df_filtrado["Dt Entrada_temp"] <= pd.to_datetime("2025-02-28"))
]

# Criar uma lista para armazenar as informações agrupadas
resultado = []

# Incluir a coluna 'Tupla_Dados' na lista de colunas a serem agregadas
for (subgrupo, codigo_produto, cliente), grupo in df_filtrado.groupby(["Subgrupo", "Código Produto", "Cliente"]):
    linha = {
        "Subgrupo": subgrupo,
        "Código Produto": codigo_produto,
        "Cliente": cliente
    }

    # Ordenar os dados por data
    grupo_ordenado = grupo.sort_values("Dt Entrada_temp")  # Ordenar pelo campo temporário de data

    # Incluir todas as colunas de df_resultado_final
    for col in df_resultado_final.columns:
        if col in ["Dt Entrada", "Prob.Fech.", "Motivo Não Venda", "Tupla_Dados"]:  # Colunas a serem agregadas em listas
            linha[col] = grupo_ordenado[col].tolist()
        elif col != "Tupla_Dados":  # Tupla_Dados foi removida anteriormente
            linha[col] = list(grupo_ordenado[col])  # Agregar demais colunas em listas
            # Converter para valor único se todos os valores forem iguais
            if len(linha[col]) > 0 and all(x == linha[col][0] for x in linha[col]):
                linha[col] = linha[col][0]

    # Calcular a última data e o último consultor para o grupo
    ultima_data_grupo = max(grupo_ordenado["Dt Entrada_temp"])  # Última data
    linha["Última Data"] = ultima_data_grupo.strftime("%d/%m/%Y")  # Formatar a última data
    linha["Último Consultor"] = grupo_ordenado.loc[grupo_ordenado["Dt Entrada_temp"] == ultima_data_grupo, "Consultor Interno"].iloc[0]  # Último consultor

    resultado.append(linha)

# Criar um novo dataframe com o resultado
df_final = pd.DataFrame(resultado)

# Reorganizar as colunas para uma ordem mais lógica (opcional)
# ...

# Inserir a nova coluna "Último Consultor" à direita da coluna "Última Data"
ultima_data_index = df_final.columns.get_loc("Última Data")  # Obter o índice da coluna "Última Data"
df_final.insert(ultima_data_index + 1, "Último Consultor", df_final.pop("Último Consultor"))  # Inserir a nova coluna à direita de "Última Data"

# Formatar a coluna "Tupla_Dados"
df_final['Tupla_Dados'] = df_final['Tupla_Dados'].apply(formatar_tupla)

# Exibir o DataFrame resultante
df_final

# Função para criar botões clicáveis
def criar_botao():
    # Estado inicial do botão: "X" vermelho
    botao = widgets.ToggleButton(
        value=False,
        description='X',
        disabled=False,
        button_style='danger',  # Vermelho
        tooltip='Clique para alternar'
    )

    # Função para atualizar o botão quando clicado
    def on_click(change):
        if change['new']:
            botao.description = '✓'
            botao.button_style = 'success'  # Verde
        else:
            botao.description = 'X'
            botao.button_style = 'danger'  # Vermelho

    # Vincular a função ao evento de clique
    botao.observe(on_click, names='value')

    return botao

# Adicionar a coluna "FUP" com botões clicáveis
df_final["FUP"] = [criar_botao() for _ in range(len(df_final))]

# Função para exibir o DataFrame com os botões
def exibir_dataframe_interativo(df):
    # Criar uma interface para exibir o DataFrame
    display(df)

# Exibir o DataFrame interativo
exibir_dataframe_interativo(df_final)